/*
 * main.c
 *
 *  Created on: 14 февр. 2016 г.
 *      Author: kruci_000
 */

#include "Modules/telemetry/telemetry.h"
#include "Modules/BMP/bmp.h"
#include "Modules/I2C/i2c.h"
#include "Modules/HMC/HMC.h"
#include "Modules/MPU6050/mpu6050.h"
#include "Modules/PID/PID.h"
#include "Modules/micros/micros.h"
#include "Modules/Servo/servo.h"

#include "../hal/hal.h"
#include "../mss_hw_platform.h"
#include "../CMSIS/m2sxxx.h"

#include "../drivers/CoreI2C/core_i2c.h"
#include "../drivers/CorePWM/core_pwm.h"
#include "../drivers/CoreUARTapb/core_uart_apb.h"
#include "../drivers_config/sys_config/sys_config.h"

#include <stdlib.h>
#include <math.h>

#define BAUD_VALUE_115200   26
#define PWM_PRESCALE        249
#define PWM_PERIOD          3999
#define threshold           20
#define magn_skip_val       10

UART_instance_t g_bt;
pwm_instance_t  g_pwm;

void press_any_key_to_continue(void);
void setup();

int main(void)
{
    uint8_t rx_buff[128];
    uint8_t print_buf[5];
    uint8_t rx_size = 0, rd_pos = 0, wr_pos = 0; // used for receiving BT data
    uint8_t magn_skip = 0, telemetry_skip = 1, telemetry_skip_counter = 0; // skip doing some operation
    int16_t ax = 0, ay = 0, az = 0;
    int16_t gx = 0, gy = 0, gz = 0;
    int16_t mx = 0, my = 0, mz = 0; //raw values from gy87
    int16_t acell_pitch, acell_roll, magn_yaw; // half raw angle
    int16_t pitch, roll, yaw; // true data
    int16_t pitch0 = 0, roll0 = 0, yaw0; // îòêëîíåíèå îò îðèåíòèðîâ çàäàâàåìîå ñ ïóëüòà
    int16_t force = 0;
    int16_t m_power[4] = {0,0,0,0};
    uint64_t t_prev; uint32_t d_t = 0; // variables for time calculation
    uint16_t print_mask = 0;
    uint8_t motor_mask = 0x0F;
    uint8_t i = 0;
    uint32_t servo_dt = 300; // Example value

    setup();

    press_any_key_to_continue();
    UART_polled_tx_string(&g_bt, (const uint8_t *)"Hello, I am Rover! (Press to continue)\n");
    press_any_key_to_continue();
    UART_polled_tx_string(&g_bt, (const uint8_t *)"Press to calibration!\n");
    press_any_key_to_continue();

    MPU6050_calibration();

    UART_polled_tx_string(&g_bt, (const uint8_t *)"Okay, let's burn it!\n");
    press_any_key_to_continue();

    t_prev = micros();
    while (1 == 1)
    {
        rx_size = UART_get_rx(&g_bt, rx_buff, 1);
        if (rx_size >= 1)
        {
			switch (rx_buff[0])
			{
				case '<':
				{
					servo_dt -= 10;
					itoa(servo_dt, print_buf, 10);
					UART_polled_tx_string(&g_bt, print_buf);
					UART_polled_tx_string(&g_bt, (const uint8_t*)'\r\n');
					break;
				}
				case '>':
				{
					servo_dt += 10;
					itoa(servo_dt, print_buf, 10);
					UART_send(&g_bt, (const uint8_t*)print_buf, 5);
					UART_polled_tx_string(&g_bt, (const uint8_t*)'\n');
					break;
				}
			}
        }

        PWM_set_duty_cycle(&g_pwm, PWM_9, servo_dt);
/*
        if(magn_skip > magn_skip_val)
        {
            HMC_get_true_Data(&mz, &my, &mx);
            magn_skip = 0;
        }
        else
            magn_skip++;
        MPU6050_getMotion6(&az, &ay, &ax, &gz, &gy, &gx, 1); // get raw data
        acell_angle(&ax, &ay, &az, &acell_pitch, &acell_roll);
        d_t = micros() - t_prev;
        t_prev = micros();
        if(d_t > 50000) // if shit happened and delta time is so big
        {
            d_t = 0;
        }
        my_angle(&gx, &gy, &gz, &acell_pitch, &acell_roll, &magn_yaw, &pitch, &roll, &yaw, d_t);
        my_yaw(&mx, &my, &mz, &magn_yaw, &pitch, &roll);

        pitch += pitch0;
        roll += roll0;
        my_PID(&pitch, &roll, &yaw, m_power, &force, &gx, &gy, &gz, d_t);
*/
//------------------ send telemetry
        /*
        if(telemetry_skip_counter > telemetry_skip)
        {
            telemetry_skip_counter = 0;

            send_telemetry( &g_bt,
                            print_mask,
                            pitch, roll, yaw,
                            get_P_p(), get_I_p(), get_D_p(),
                            get_P_r(), get_I_r(), get_D_r(),
                            get_P_y(), get_I_y(), get_D_y(),
                            d_t);
        }
        else
            telemetry_skip_counter++;
        */
//------------------ send telemetry finished
    }
    return 0;
}



void press_any_key_to_continue(void)
{
    size_t rx_size;
    uint8_t rx_char;
    do {
        rx_size = UART_get_rx(&g_bt, &rx_char, sizeof(rx_char));
    } while(rx_size == 0);
}
/*------------------------------------------------------------------------------
 * Service the I2C timeout functionality.
 */
void SysTick_Handler(void)
{
    I2C_system_tick(&g_core_i2c0, 10);
}
void FabricIrq0_IRQHandler(void)
{
    I2C_isr(&g_core_i2c0);
}
void setup()
{
    PWM_init(&g_pwm, COREPWM_0_0, PWM_PRESCALE, PWM_PERIOD);
    PWM_enable(&g_pwm, PWM_9);
    //Servo_init(PWM_PRESCALE, PWM_PERIOD);
    //Servo_enable();
    UART_init(&g_bt, COREUARTAPB_2_0, BAUD_VALUE_115200, (DATA_8_BITS | NO_PARITY));
    i2c_init(1); // argument no matter
    BMP_calibrate();
    MPU6050_initialize();
    MPU6050_setDLPFMode(0);
    MPU6050_setFullScaleGyroRange(1); // it's must set range of gyro's data     +-500(deg/sec)
    HMC_init();

    MSS_TIM1_init(MSS_TIMER_PERIODIC_MODE);
    NVIC_SetPriority(SysTick_IRQn, 0xFFu); /* Lowest possible priority */
    SysTick_Config(MSS_SYS_M3_CLK_FREQ / 100);
    init_timer();// run timer for micros();
}


